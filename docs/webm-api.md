# WebM Asset API Specification

This document outlines the planned HTTP endpoints for managing WebM animation assets that back invitation designs. The endpoints are implemented against the lightweight persistence helpers exposed from [`server/webm-store.js`](../server/webm-store.js), which track metadata for each stored file.

## Authentication & Authorization

All endpoints sit behind the existing authenticated session or JWT bearer token middleware.

- **Authenticated user scope**: Authenticated end users may only interact with WebM records linked to designs they own. The server enforces ownership by looking up the `designOwners` map before delegating to the store helpers.
- **Admin/Staff scope**: Accounts flagged with an `admin` role bypass ownership checks and may view or mutate any WebM record. Admin traffic is still audited per standard platform policy.
- **Unauthenticated traffic**: Requests without a valid session or bearer token receive a `401 Unauthorized` response. Authenticated users without access to a specific design receive `403 Forbidden`.
- **Transport & rate limits**: HTTPS is required. Standard API rate limits (60 requests/minute unless otherwise noted) apply; large uploads should leverage resumable or signed URL flows to stay within limits.

## Metadata Model

`webm-store.js` persists the following properties per WebM asset:

| Field            | Type      | Notes |
| ---------------- | --------- | ----- |
| `id`             | string    | Stable identifier generated by the store. |
| `designId`       | string    | Foreign key to the invitation design. Must reference an existing design record. |
| `storageUri`     | string    | Absolute or bucket URI pointing to the binary object (e.g., `https://cdn.example.com/webm/asset_1.webm`). |
| `durationSeconds`| number?   | Optional runtime duration for playback controls. Null when unknown. |
| `sizeBytes`      | number?   | Optional asset size in bytes. Useful for quota reporting. |
| `uploadedBy`     | string?   | User identifier for the account that initiated the upload. Null for system imports. |
| `createdAt`      | ISO8601 string | Auto-generated timestamp when the record is created. |
| `updatedAt`      | ISO8601 string | Auto-generated timestamp for the most recent metadata update. |

Each response body returns the full metadata record so that clients can display audit information and pass URIs to playback components.

## Upload Strategies

Two complementary upload flows are supported to accommodate varying client capabilities:

1. **Direct multipart upload**
   - Clients `POST` a `multipart/form-data` request to `/api/webm` with:
     - `file`: binary WebM payload.
     - `designId`: required text field linking the upload to a design.
     - Optional text fields: `durationSeconds`, `sizeBytes` (number strings), `uploadedBy` (overrides the authenticated user ID when acting on behalf of someone else).
   - The server streams the file to the configured blob storage service, then records the resulting `storageUri` using `addWebmFile`.
   - Recommended for quick previews and assets smaller than 25 MB.

2. **Signed URL (two-step) upload**
   - Clients `POST` JSON to `/api/webm` with `Content-Type: application/json` and the following shape:

     ```json
     {
       "designId": "dsgn_123",
       "filename": "loop.webm",
       "sizeBytes": 2843921,
       "durationSeconds": 12.4
     }
     ```
   - The server validates ownership, produces a time-limited signed PUT URL (e.g., Cloudflare R2 or S3), and *provisions a placeholder metadata record* whose `storageUri` points at the signed URL destination. The response also returns the signed URL so the client can upload directly from the browser.
   - Once the client completes the upload, it should `PATCH /api/webm/:id` to finalize metadata such as `storageUri` (if it changed), `sizeBytes`, and `durationSeconds`. This keeps the metadata consistent with the eventual object location.
   - Recommended for large files where direct proxying through the API would exceed timeout or bandwidth limits.

Both flows ultimately persist metadata through `webm-store.js`. They differ only in how the binary payload reaches storage.

## Endpoint Reference

### `POST /api/webm`
Creates a WebM metadata record and optionally proxies the binary upload.

- **Auth**: Required. User must own the design or be an admin.
- **Request**: Either a `multipart/form-data` upload (direct flow) or JSON payload (signed URL flow) as described above. When using multipart, the server infers `uploadedBy` from the authenticated user if not provided.
- **Success Response** `201 Created`:

  ```json
  {
    "id": "42",
    "designId": "dsgn_123",
    "storageUri": "https://cdn.example.com/webm/42.webm",
    "durationSeconds": 12.4,
    "sizeBytes": 2843921,
    "uploadedBy": "user_9",
    "createdAt": "2024-06-01T18:22:11.904Z",
    "updatedAt": "2024-06-01T18:22:11.904Z",
    "upload": {
      "signedUrl": "https://upload.example.com/signed/abc123",
      "expiresAt": "2024-06-01T18:37:11.904Z"
    }
  }
  ```

  - The `upload` object is only present for signed URL flows. Direct uploads omit it.
- **Validation Errors** `422 Unprocessable Entity`: Missing `designId`, unsupported MIME type, exceeded size limit, etc.

### `GET /api/webm/:id`
Retrieve a single WebM metadata record.

- **Auth**: Required. Owner or admin.
- **Response** `200 OK`:

  ```json
  {
    "id": "42",
    "designId": "dsgn_123",
    "storageUri": "https://cdn.example.com/webm/42.webm",
    "durationSeconds": 12.4,
    "sizeBytes": 2843921,
    "uploadedBy": "user_9",
    "createdAt": "2024-06-01T18:22:11.904Z",
    "updatedAt": "2024-06-01T18:22:11.904Z"
  }
  ```
- **Errors**:
  - `404 Not Found` if the ID does not exist.
  - `403 Forbidden` if the caller lacks access to the associated design.

### `GET /api/designs/:id/webm`
List all WebM assets tied to a design.

- **Auth**: Required. Owner of the design or admin.
- **Query Parameters**:
  - `includeDeleted` (future-proofing) — optional boolean to include soft-deleted assets. Currently defaults to `false` and is ignored by `webm-store.js`, but reserved for eventual audit features.
- **Response** `200 OK`:

  ```json
  {
    "designId": "dsgn_123",
    "data": [
      {
        "id": "42",
        "storageUri": "https://cdn.example.com/webm/42.webm",
        "durationSeconds": 12.4,
        "sizeBytes": 2843921,
        "uploadedBy": "user_9",
        "createdAt": "2024-06-01T18:22:11.904Z",
        "updatedAt": "2024-06-01T18:22:11.904Z"
      }
    ]
  }
  ```

### `PATCH /api/webm/:id`
Update mutable metadata fields for an existing asset.

- **Auth**: Required. Owner of the design or admin.
- **Request Body** `application/json`: Any subset of the mutable keys `designId`, `storageUri`, `durationSeconds`, `sizeBytes`, `uploadedBy`.

  ```json
  {
    "durationSeconds": 12.4,
    "sizeBytes": 2843921,
    "storageUri": "https://cdn.example.com/webm/42.webm"
  }
  ```

- **Response** `200 OK`: Returns the updated metadata record (same shape as `GET /api/webm/:id`).
- **Errors**:
  - `404 Not Found` if the asset does not exist.
  - `403 Forbidden` if the caller cannot mutate the related design.
  - `422 Unprocessable Entity` when attempting to reassign `designId` to a design the caller does not own or that does not exist (`webm-store` throws an error when a design ID is invalid).

### `DELETE /api/webm/:id`
(Planned) Soft-delete an asset while retaining metadata for auditing.

- **Auth**: Admin or design owner.
- **Behavior**: Marks the record as deleted (flag to be added to `webm-store.js`). The binary object remains in storage until separate retention policies purge it.
- **Response** `204 No Content`.

## Error Envelope

All endpoints return a consistent JSON envelope for error cases:

```json
{
  "error": {
    "type": "authorization_error",
    "message": "Design ownership required"
  }
}
```

`type` may be `validation_error`, `not_found`, or `server_error` depending on context.

## Audit & Observability

- Mutating endpoints record `uploadedBy`, timestamp, and the authenticated user ID in structured logs.
- Admin overrides (uploading on behalf of another user) must include the target user's ID in the request body to keep `uploadedBy` accurate.
- Storage URIs should be validated to ensure they point to expected buckets/prefixes before persisting metadata to prevent exfiltration via malicious URIs.

## Open Questions

- Should uploads automatically transcode to normalized bitrate and resolution, or will the client pre-process assets?
- Does the platform require lifecycle hooks to clean up orphaned signed URLs or placeholder records that never complete uploading?
- Will we expose CDN-signed playback URLs or rely on public bucket ACLs?
